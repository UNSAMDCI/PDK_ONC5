//****************************************************************************//
// Verilog models generated by SiliconSmart L-2016.06-SP1-1 build date: Sep 28, 2016 18:12:52. (SMSC-2) //
// Siliconsmart Path: /opt/synopsys/silicon_smart/L-2016.06-SP1-1/linux64/bin/siliconsmart //
// Host Name: unsam.pc, User Name: digital, PID: 18100                       //
// Directory: /home/digital/siliconSmart                                      //
//                                                                            //
// File generated on Thu Jul 13 19:18:08 -03 2017. (SMSC-3)                   //
//****************************************************************************//


`timescale 1ns/1ps



`celldefine
module AN21X1( OUT, A, B, C );
input A, B, C;
output OUT;

   `ifdef FUNCTIONAL  //  functional //

	AN21X1_func AN21X1_behav_inst(.OUT(OUT),.A(A),.B(B),.C(C));
   `else

	AN21X1_func AN21X1_inst(.OUT(OUT),.A(A),.B(B),.C(C));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> OUT
	 (A => OUT) = (1.0,1.0);

	// comb arc B --> OUT
	 (B => OUT) = (1.0,1.0);

	// comb arc C --> OUT
	 (C => OUT) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module AND2X1( OUT, A, B );
input A, B;
output OUT;

   `ifdef FUNCTIONAL  //  functional //

	AND2X1_func AND2X1_behav_inst(.OUT(OUT),.A(A),.B(B));
   `else

	AND2X1_func AND2X1_inst(.OUT(OUT),.A(A),.B(B));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> OUT
	 (A => OUT) = (1.0,1.0);

	// comb arc B --> OUT
	 (B => OUT) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module AND3X1( OUT, A, B, C );
input A, B, C;
output OUT;

   `ifdef FUNCTIONAL  //  functional //

	AND3X1_func AND3X1_behav_inst(.OUT(OUT),.A(A),.B(B),.C(C));
   `else

	AND3X1_func AND3X1_inst(.OUT(OUT),.A(A),.B(B),.C(C));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> OUT
	 (A => OUT) = (1.0,1.0);

	// comb arc B --> OUT
	 (B => OUT) = (1.0,1.0);

	// comb arc C --> OUT
	 (C => OUT) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module AND4X1( OUT, C, D, B, A );
input A, B, C, D;
output OUT;

   `ifdef FUNCTIONAL  //  functional //

	AND4X1_func AND4X1_behav_inst(.OUT(OUT),.C(C),.D(D),.B(B),.A(A));
   `else

	AND4X1_func AND4X1_inst(.OUT(OUT),.C(C),.D(D),.B(B),.A(A));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> OUT
	 (A => OUT) = (1.0,1.0);

	// comb arc B --> OUT
	 (B => OUT) = (1.0,1.0);

	// comb arc C --> OUT
	 (C => OUT) = (1.0,1.0);

	// comb arc D --> OUT
	 (D => OUT) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module AND5X1( OUT, C, D, E, B, A );
input A, B, C, D, E;
output OUT;

   `ifdef FUNCTIONAL  //  functional //

	AND5X1_func AND5X1_behav_inst(.OUT(OUT),.C(C),.D(D),.E(E),.B(B),.A(A));
   `else

	AND5X1_func AND5X1_inst(.OUT(OUT),.C(C),.D(D),.E(E),.B(B),.A(A));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> OUT
	 (A => OUT) = (1.0,1.0);

	// comb arc B --> OUT
	 (B => OUT) = (1.0,1.0);

	// comb arc C --> OUT
	 (C => OUT) = (1.0,1.0);

	// comb arc D --> OUT
	 (D => OUT) = (1.0,1.0);

	// comb arc E --> OUT
	 (E => OUT) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module AND6X1( OUT, C, D, F, E, B, A );
input A, B, C, D, E, F;
output OUT;

   `ifdef FUNCTIONAL  //  functional //

	AND6X1_func AND6X1_behav_inst(.OUT(OUT),.C(C),.D(D),.F(F),.E(E),.B(B),.A(A));
   `else

	AND6X1_func AND6X1_inst(.OUT(OUT),.C(C),.D(D),.F(F),.E(E),.B(B),.A(A));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> OUT
	 (A => OUT) = (1.0,1.0);

	// comb arc B --> OUT
	 (B => OUT) = (1.0,1.0);

	// comb arc C --> OUT
	 (C => OUT) = (1.0,1.0);

	// comb arc D --> OUT
	 (D => OUT) = (1.0,1.0);

	// comb arc E --> OUT
	 (E => OUT) = (1.0,1.0);

	// comb arc F --> OUT
	 (F => OUT) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module AO21X1( OUT, B, A, C );
input A, B, C;
output OUT;

   `ifdef FUNCTIONAL  //  functional //

	AO21X1_func AO21X1_behav_inst(.OUT(OUT),.B(B),.A(A),.C(C));
   `else

	AO21X1_func AO21X1_inst(.OUT(OUT),.B(B),.A(A),.C(C));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> OUT
	 (A => OUT) = (1.0,1.0);

	// comb arc B --> OUT
	 (B => OUT) = (1.0,1.0);

	// comb arc C --> OUT
	 (C => OUT) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module AO222X1( OUT, E, F, D, C, B, A );
input A, B, C, D, E, F;
output OUT;

   `ifdef FUNCTIONAL  //  functional //

	AO222X1_func AO222X1_behav_inst(.OUT(OUT),.E(E),.F(F),.D(D),.C(C),.B(B),.A(A));
   `else

	AO222X1_func AO222X1_inst(.OUT(OUT),.E(E),.F(F),.D(D),.C(C),.B(B),.A(A));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> OUT
	 (A => OUT) = (1.0,1.0);

	// comb arc B --> OUT
	 (B => OUT) = (1.0,1.0);

	// comb arc C --> OUT
	 (C => OUT) = (1.0,1.0);

	// comb arc D --> OUT
	 (D => OUT) = (1.0,1.0);

	// comb arc E --> OUT
	 (E => OUT) = (1.0,1.0);

	// comb arc F --> OUT
	 (F => OUT) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module AO22X1( OUT, C, D, B, A );
input A, B, C, D;
output OUT;

   `ifdef FUNCTIONAL  //  functional //

	AO22X1_func AO22X1_behav_inst(.OUT(OUT),.C(C),.D(D),.B(B),.A(A));
   `else

	AO22X1_func AO22X1_inst(.OUT(OUT),.C(C),.D(D),.B(B),.A(A));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> OUT
	 (A => OUT) = (1.0,1.0);

	// comb arc B --> OUT
	 (B => OUT) = (1.0,1.0);

	// comb arc C --> OUT
	 (C => OUT) = (1.0,1.0);

	// comb arc D --> OUT
	 (D => OUT) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module AO31X1( OUT, A, B, C, D );
input A, B, C, D;
output OUT;

   `ifdef FUNCTIONAL  //  functional //

	AO31X1_func AO31X1_behav_inst(.OUT(OUT),.A(A),.B(B),.C(C),.D(D));
   `else

	AO31X1_func AO31X1_inst(.OUT(OUT),.A(A),.B(B),.C(C),.D(D));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> OUT
	 (A => OUT) = (1.0,1.0);

	// comb arc B --> OUT
	 (B => OUT) = (1.0,1.0);

	// comb arc C --> OUT
	 (C => OUT) = (1.0,1.0);

	// comb arc D --> OUT
	 (D => OUT) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module AO32X1( OUT, A, B, C, E, D );
input A, B, C, D, E;
output OUT;

   `ifdef FUNCTIONAL  //  functional //

	AO32X1_func AO32X1_behav_inst(.OUT(OUT),.A(A),.B(B),.C(C),.E(E),.D(D));
   `else

	AO32X1_func AO32X1_inst(.OUT(OUT),.A(A),.B(B),.C(C),.E(E),.D(D));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> OUT
	 (A => OUT) = (1.0,1.0);

	// comb arc B --> OUT
	 (B => OUT) = (1.0,1.0);

	// comb arc C --> OUT
	 (C => OUT) = (1.0,1.0);

	// comb arc D --> OUT
	 (D => OUT) = (1.0,1.0);

	// comb arc E --> OUT
	 (E => OUT) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module BUF1X4( OUT, IN );
input IN;
output OUT;

   `ifdef FUNCTIONAL  //  functional //

	BUF1X4_func BUF1X4_behav_inst(.OUT(OUT),.IN(IN));
   `else

	BUF1X4_func BUF1X4_inst(.OUT(OUT),.IN(IN));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc IN --> OUT
	 (IN => OUT) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module BUF2X8( OUT, IN );
input IN;
output OUT;

   `ifdef FUNCTIONAL  //  functional //

	BUF2X8_func BUF2X8_behav_inst(.OUT(OUT),.IN(IN));
   `else

	BUF2X8_func BUF2X8_inst(.OUT(OUT),.IN(IN));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc IN --> OUT
	 (IN => OUT) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module BUX1( OUT, IN );
input IN;
output OUT;

   `ifdef FUNCTIONAL  //  functional //

	BUX1_func BUX1_behav_inst(.OUT(OUT),.IN(IN));
   `else

	BUX1_func BUX1_inst(.OUT(OUT),.IN(IN));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc IN --> OUT
	 (IN => OUT) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module BUX2( OUT, IN );
input IN;
output OUT;

   `ifdef FUNCTIONAL  //  functional //

	BUX2_func BUX2_behav_inst(.OUT(OUT),.IN(IN));
   `else

	BUX2_func BUX2_inst(.OUT(OUT),.IN(IN));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc IN --> OUT
	 (IN => OUT) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module BUX3( OUT, IN );
input IN;
output OUT;

   `ifdef FUNCTIONAL  //  functional //

	BUX3_func BUX3_behav_inst(.OUT(OUT),.IN(IN));
   `else

	BUX3_func BUX3_inst(.OUT(OUT),.IN(IN));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc IN --> OUT
	 (IN => OUT) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module BUX4( OUT, IN );
input IN;
output OUT;

   `ifdef FUNCTIONAL  //  functional //

	BUX4_func BUX4_behav_inst(.OUT(OUT),.IN(IN));
   `else

	BUX4_func BUX4_inst(.OUT(OUT),.IN(IN));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc IN --> OUT
	 (IN => OUT) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module BUX6( OUT, IN );
input IN;
output OUT;

   `ifdef FUNCTIONAL  //  functional //

	BUX6_func BUX6_behav_inst(.OUT(OUT),.IN(IN));
   `else

	BUX6_func BUX6_inst(.OUT(OUT),.IN(IN));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc IN --> OUT
	 (IN => OUT) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module BUX8( Z, IN );
input IN;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	BUX8_func BUX8_behav_inst(.Z(Z),.IN(IN));
   `else

	BUX8_func BUX8_inst(.Z(Z),.IN(IN));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc IN --> Z
	 (IN => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module DFFX1( QN, Q, D, ICLK );
input D, ICLK;
output Q, QN;

   `ifdef FUNCTIONAL  //  functional //

	DFFX1_func DFFX1_behav_inst(.QN(QN),.Q(Q),.D(D),.ICLK(ICLK));
   `else

	DFFX1_func DFFX1_inst(.QN(QN),.Q(Q),.D(D),.ICLK(ICLK));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc ICLK --> Q
	(negedge ICLK => (Q : D))  = (1.0,1.0);

	// seq arc ICLK --> QN
	(negedge ICLK => (QN : D))  = (1.0,1.0);

	// hold D-HL ICLK-HL
	$hold(negedge ICLK,negedge D,1.0);

	// hold D-LH ICLK-HL
	$hold(negedge ICLK,posedge D,1.0);

	// setup D-HL ICLK-HL
	$setup(negedge D,negedge ICLK,1.0);

	// setup D-LH ICLK-HL
	$setup(posedge D,negedge ICLK,1.0);

	// mpw ICLK_lh 
	$width(posedge ICLK,1.0,0);

	// mpw ICLK_hl 
	$width(negedge ICLK,1.0,0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module DFRQX1( Q, ICLK, D );
input D, ICLK;
output Q;

   `ifdef FUNCTIONAL  //  functional //

	DFRQX1_func DFRQX1_behav_inst(.Q(Q),.ICLK(ICLK),.D(D));
   `else

	DFRQX1_func DFRQX1_inst(.Q(Q),.ICLK(ICLK),.D(D));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc ICLK --> Q
	(posedge ICLK => (Q : D))  = (1.0,1.0);

	// hold D-HL ICLK-LH
	$hold(posedge ICLK,negedge D,1.0);

	// hold D-LH ICLK-LH
	$hold(posedge ICLK,posedge D,1.0);

	// setup D-HL ICLK-LH
	$setup(negedge D,posedge ICLK,1.0);

	// setup D-LH ICLK-LH
	$setup(posedge D,posedge ICLK,1.0);

	// mpw ICLK_lh 
	$width(posedge ICLK,1.0,0);

	// mpw ICLK_hl 
	$width(negedge ICLK,1.0,0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module DFRRSX1( Q, QN, ICLK, D, RN, SN );
input D, ICLK, RN, SN;
output Q, QN;

   `ifdef FUNCTIONAL  //  functional //

	DFRRSX1_func DFRRSX1_behav_inst(.Q(Q),.QN(QN),.ICLK(ICLK),.D(D),.RN(RN),.SN(SN));
   `else

	DFRRSX1_func DFRRSX1_inst(.Q(Q),.QN(QN),.ICLK(ICLK),.D(D),.RN(RN),.SN(SN));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc ICLK --> Q
	(posedge ICLK => (Q : D))  = (1.0,1.0);

	// seq arc RN --> Q
	(RN => Q)  = (1.0,1.0);

	// seq arc SN --> Q
	(SN => Q)  = (1.0,1.0);

	// seq arc ICLK --> QN
	(posedge ICLK => (QN : D))  = (1.0,1.0);

	// seq arc RN --> QN
	(RN => QN)  = (1.0,1.0);

	// seq arc SN --> QN
	(SN => QN)  = (1.0,1.0);

	// hold D-HL ICLK-LH
	$hold(posedge ICLK,negedge D,1.0);

	// hold D-LH ICLK-LH
	$hold(posedge ICLK,posedge D,1.0);

	// setup D-HL ICLK-LH
	$setup(negedge D,posedge ICLK,1.0);

	// setup D-LH ICLK-LH
	$setup(posedge D,posedge ICLK,1.0);

	// recovery RN-LH ICLK-LH
	$recovery(posedge RN,posedge ICLK,1.0);

	// removal RN-LH ICLK-LH
	$removal(posedge RN,posedge ICLK,1.0);

	// hold RN-LH SN-LH
	$hold(posedge SN,posedge RN,1.0);

	// setup RN-LH SN-LH
	$setup(posedge RN,posedge SN,1.0);

	// recovery SN-LH ICLK-LH
	$recovery(posedge SN,posedge ICLK,1.0);

	// removal SN-LH ICLK-LH
	$removal(posedge SN,posedge ICLK,1.0);

	// hold SN-LH RN-LH
	$hold(posedge RN,posedge SN,1.0);

	// setup SN-LH RN-LH
	$setup(posedge SN,posedge RN,1.0);

	// mpw ICLK_lh 
	$width(posedge ICLK,1.0,0);

	// mpw ICLK_hl 
	$width(negedge ICLK,1.0,0);

	// mpw RN_hl 
	$width(negedge RN,1.0,0);

	// mpw SN_hl 
	$width(negedge SN,1.0,0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module DFRRX1( QN, Q, ICLK, D, RN );
input D, ICLK, RN;
output Q, QN;

   `ifdef FUNCTIONAL  //  functional //

	DFRRX1_func DFRRX1_behav_inst(.QN(QN),.Q(Q),.ICLK(ICLK),.D(D),.RN(RN));
   `else

	DFRRX1_func DFRRX1_inst(.QN(QN),.Q(Q),.ICLK(ICLK),.D(D),.RN(RN));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc ICLK --> Q
	(posedge ICLK => (Q : D))  = (1.0,1.0);

	// seq arc RN --> Q
	(RN => Q)  = (1.0,1.0);

	// seq arc ICLK --> QN
	(posedge ICLK => (QN : D))  = (1.0,1.0);

	// seq arc RN --> QN
	(RN => QN)  = (1.0,1.0);

	// hold D-HL ICLK-LH
	$hold(posedge ICLK,negedge D,1.0);

	// hold D-LH ICLK-LH
	$hold(posedge ICLK,posedge D,1.0);

	// setup D-HL ICLK-LH
	$setup(negedge D,posedge ICLK,1.0);

	// setup D-LH ICLK-LH
	$setup(posedge D,posedge ICLK,1.0);

	// recovery RN-LH ICLK-LH
	$recovery(posedge RN,posedge ICLK,1.0);

	// removal RN-LH ICLK-LH
	$removal(posedge RN,posedge ICLK,1.0);

	// mpw ICLK_lh 
	$width(posedge ICLK,1.0,0);

	// mpw ICLK_hl 
	$width(negedge ICLK,1.0,0);

	// mpw RN_hl 
	$width(negedge RN,1.0,0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module DFRX1( Q, QN, D, ICLK );
input D, ICLK;
output Q, QN;

   `ifdef FUNCTIONAL  //  functional //

	DFRX1_func DFRX1_behav_inst(.Q(Q),.QN(QN),.D(D),.ICLK(ICLK));
   `else

	DFRX1_func DFRX1_inst(.Q(Q),.QN(QN),.D(D),.ICLK(ICLK));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc ICLK --> Q
	(posedge ICLK => (Q : D))  = (1.0,1.0);

	// seq arc ICLK --> QN
	(posedge ICLK => (QN : D))  = (1.0,1.0);

	// hold D-HL ICLK-LH
	$hold(posedge ICLK,negedge D,1.0);

	// hold D-LH ICLK-LH
	$hold(posedge ICLK,posedge D,1.0);

	// setup D-HL ICLK-LH
	$setup(negedge D,posedge ICLK,1.0);

	// setup D-LH ICLK-LH
	$setup(posedge D,posedge ICLK,1.0);

	// mpw ICLK_lh 
	$width(posedge ICLK,1.0,0);

	// mpw ICLK_hl 
	$width(negedge ICLK,1.0,0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module DLHLX1( Q, QN, G, D );
input D, G;
output Q, QN;

   `ifdef FUNCTIONAL  //  functional //

	DLHLX1_func DLHLX1_behav_inst(.Q(Q),.QN(QN),.G(G),.D(D));
   `else

	DLHLX1_func DLHLX1_inst(.Q(Q),.QN(QN),.G(G),.D(D));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// seq arc G --> Q
	(posedge G => (Q : D))  = (1.0,1.0);

	// comb arc D --> QN
	 (D => QN) = (1.0,1.0);

	// seq arc G --> QN
	(posedge G => (QN : D))  = (1.0,1.0);

	// hold D-HL G-HL
	$hold(negedge G,negedge D,1.0);

	// hold D-LH G-HL
	$hold(negedge G,posedge D,1.0);

	// setup D-HL G-HL
	$setup(negedge D,negedge G,1.0);

	// setup D-LH G-HL
	$setup(posedge D,negedge G,1.0);

	// mpw G_lh 
	$width(posedge G,1.0,0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module DLHQLX1( Q, G, D );
input D, G;
output Q;

   `ifdef FUNCTIONAL  //  functional //

	DLHQLX1_func DLHQLX1_behav_inst(.Q(Q),.G(G),.D(D));
   `else

	DLHQLX1_func DLHQLX1_inst(.Q(Q),.G(G),.D(D));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// seq arc G --> Q
	(posedge G => (Q : D))  = (1.0,1.0);

	// hold D-HL G-HL
	$hold(negedge G,negedge D,1.0);

	// hold D-LH G-HL
	$hold(negedge G,posedge D,1.0);

	// setup D-HL G-HL
	$setup(negedge D,negedge G,1.0);

	// setup D-LH G-HL
	$setup(posedge D,negedge G,1.0);

	// mpw G_lh 
	$width(posedge G,1.0,0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module DLHRLX1( Q, QN, D, G, R );
input D, G, R;
output Q, QN;

   `ifdef FUNCTIONAL  //  functional //

	DLHRLX1_func DLHRLX1_behav_inst(.Q(Q),.QN(QN),.D(D),.G(G),.R(R));
   `else

	DLHRLX1_func DLHRLX1_inst(.Q(Q),.QN(QN),.D(D),.G(G),.R(R));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// seq arc G --> Q
	(posedge G => (Q : D))  = (1.0,1.0);

	// seq arc R --> Q
	(R => Q)  = (1.0,1.0);

	// comb arc D --> QN
	 (D => QN) = (1.0,1.0);

	// seq arc G --> QN
	(posedge G => (QN : D))  = (1.0,1.0);

	// seq arc R --> QN
	(R => QN)  = (1.0,1.0);

	// hold D-HL G-HL
	$hold(negedge G,negedge D,1.0);

	// hold D-LH G-HL
	$hold(negedge G,posedge D,1.0);

	// setup D-HL G-HL
	$setup(negedge D,negedge G,1.0);

	// setup D-LH G-HL
	$setup(posedge D,negedge G,1.0);

	// recovery R-LH G-HL
	$recovery(posedge R,negedge G,1.0);

	// removal R-LH G-HL
	$removal(posedge R,negedge G,1.0);

	// mpw G_lh 
	$width(posedge G,1.0,0);

	// mpw R_hl 
	$width(negedge R,1.0,0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module DLHRQLX1( Q, G, D, R );
input D, G, R;
output Q;

   `ifdef FUNCTIONAL  //  functional //

	DLHRQLX1_func DLHRQLX1_behav_inst(.Q(Q),.G(G),.D(D),.R(R));
   `else

	DLHRQLX1_func DLHRQLX1_inst(.Q(Q),.G(G),.D(D),.R(R));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// seq arc G --> Q
	(posedge G => (Q : D))  = (1.0,1.0);

	// seq arc R --> Q
	(R => Q)  = (1.0,1.0);

	// hold D-HL G-HL
	$hold(negedge G,negedge D,1.0);

	// hold D-LH G-HL
	$hold(negedge G,posedge D,1.0);

	// setup D-HL G-HL
	$setup(negedge D,negedge G,1.0);

	// setup D-LH G-HL
	$setup(posedge D,negedge G,1.0);

	// recovery R-LH G-HL
	$recovery(posedge R,negedge G,1.0);

	// removal R-LH G-HL
	$removal(posedge R,negedge G,1.0);

	// mpw G_lh 
	$width(posedge G,1.0,0);

	// mpw R_hl 
	$width(negedge R,1.0,0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module DLY1LX1( Q, D );
input D;
output Q;

   `ifdef FUNCTIONAL  //  functional //

	DLY1LX1_func DLY1LX1_behav_inst(.Q(Q),.D(D));
   `else

	DLY1LX1_func DLY1LX1_inst(.Q(Q),.D(D));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module DLY1p6LX1( Q, D );
input D;
output Q;

   `ifdef FUNCTIONAL  //  functional //

	DLY1p6LX1_func DLY1p6LX1_behav_inst(.Q(Q),.D(D));
   `else

	DLY1p6LX1_func DLY1p6LX1_inst(.Q(Q),.D(D));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module DLY2LX1( Q, D );
input D;
output Q;

   `ifdef FUNCTIONAL  //  functional //

	DLY2LX1_func DLY2LX1_behav_inst(.Q(Q),.D(D));
   `else

	DLY2LX1_func DLY2LX1_inst(.Q(Q),.D(D));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module DLY4LX1( Q, D );
input D;
output Q;

   `ifdef FUNCTIONAL  //  functional //

	DLY4LX1_func DLY4LX1_behav_inst(.Q(Q),.D(D));
   `else

	DLY4LX1_func DLY4LX1_inst(.Q(Q),.D(D));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module DLY8LX1( Q, D );
input D;
output Q;

   `ifdef FUNCTIONAL  //  functional //

	DLY8LX1_func DLY8LX1_behav_inst(.Q(Q),.D(D));
   `else

	DLY8LX1_func DLY8LX1_inst(.Q(Q),.D(D));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module EO2X1( Z, A, B );
input A, B;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	EO2X1_func EO2X1_behav_inst(.Z(Z),.A(A),.B(B));
   `else

	EO2X1_func EO2X1_inst(.Z(Z),.A(A),.B(B));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	ifnone
	// comb arc posedge A --> (Z:A)
	 (posedge A => (Z:A)) = (1.0,1.0);

	ifnone
	// comb arc negedge A --> (Z:A)
	 (negedge A => (Z:A)) = (1.0,1.0);

	ifnone
	// comb arc posedge B --> (Z:B)
	 (posedge B => (Z:B)) = (1.0,1.0);

	ifnone
	// comb arc negedge B --> (Z:B)
	 (negedge B => (Z:B)) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module FAX1( CO, S, A, B, CI );
input A, B, CI;
output CO, S;

   `ifdef FUNCTIONAL  //  functional //

	FAX1_func FAX1_behav_inst(.CO(CO),.S(S),.A(A),.B(B),.CI(CI));
   `else

	FAX1_func FAX1_inst(.CO(CO),.S(S),.A(A),.B(B),.CI(CI));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> CO
	 (A => CO) = (1.0,1.0);

	// comb arc B --> CO
	 (B => CO) = (1.0,1.0);

	// comb arc CI --> CO
	 (CI => CO) = (1.0,1.0);

	ifnone
	// comb arc posedge A --> (S:A)
	 (posedge A => (S:A)) = (1.0,1.0);

	ifnone
	// comb arc negedge A --> (S:A)
	 (negedge A => (S:A)) = (1.0,1.0);

	ifnone
	// comb arc posedge B --> (S:B)
	 (posedge B => (S:B)) = (1.0,1.0);

	ifnone
	// comb arc negedge B --> (S:B)
	 (negedge B => (S:B)) = (1.0,1.0);

	ifnone
	// comb arc posedge CI --> (S:CI)
	 (posedge CI => (S:CI)) = (1.0,1.0);

	ifnone
	// comb arc negedge CI --> (S:CI)
	 (negedge CI => (S:CI)) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module FEEDCAP2L(  );

   `ifdef FUNCTIONAL  //  functional //

	FEEDCAP2L_func FEEDCAP2L_behav_inst();
   `else

	FEEDCAP2L_func FEEDCAP2L_inst();

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module HAX1( CO, S, B, A );
input A, B;
output CO, S;

   `ifdef FUNCTIONAL  //  functional //

	HAX1_func HAX1_behav_inst(.CO(CO),.S(S),.B(B),.A(A));
   `else

	HAX1_func HAX1_inst(.CO(CO),.S(S),.B(B),.A(A));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> CO
	 (A => CO) = (1.0,1.0);

	// comb arc B --> CO
	 (B => CO) = (1.0,1.0);

	ifnone
	// comb arc posedge A --> (S:A)
	 (posedge A => (S:A)) = (1.0,1.0);

	ifnone
	// comb arc negedge A --> (S:A)
	 (negedge A => (S:A)) = (1.0,1.0);

	ifnone
	// comb arc posedge B --> (S:B)
	 (posedge B => (S:B)) = (1.0,1.0);

	ifnone
	// comb arc negedge B --> (S:B)
	 (negedge B => (S:B)) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module INX1( OUT, IN );
input IN;
output OUT;

   `ifdef FUNCTIONAL  //  functional //

	INX1_func INX1_behav_inst(.OUT(OUT),.IN(IN));
   `else

	INX1_func INX1_inst(.OUT(OUT),.IN(IN));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc IN --> OUT
	 (IN => OUT) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module INX16( OUT, IN );
input IN;
output OUT;

   `ifdef FUNCTIONAL  //  functional //

	INX16_func INX16_behav_inst(.OUT(OUT),.IN(IN));
   `else

	INX16_func INX16_inst(.OUT(OUT),.IN(IN));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc IN --> OUT
	 (IN => OUT) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module INX2( OUT, IN );
input IN;
output OUT;

   `ifdef FUNCTIONAL  //  functional //

	INX2_func INX2_behav_inst(.OUT(OUT),.IN(IN));
   `else

	INX2_func INX2_inst(.OUT(OUT),.IN(IN));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc IN --> OUT
	 (IN => OUT) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module INX32( OUT, IN );
input IN;
output OUT;

   `ifdef FUNCTIONAL  //  functional //

	INX32_func INX32_behav_inst(.OUT(OUT),.IN(IN));
   `else

	INX32_func INX32_inst(.OUT(OUT),.IN(IN));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc IN --> OUT
	 (IN => OUT) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module INX4( OUT, IN );
input IN;
output OUT;

   `ifdef FUNCTIONAL  //  functional //

	INX4_func INX4_behav_inst(.OUT(OUT),.IN(IN));
   `else

	INX4_func INX4_inst(.OUT(OUT),.IN(IN));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc IN --> OUT
	 (IN => OUT) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module INX6( OUT, IN );
input IN;
output OUT;

   `ifdef FUNCTIONAL  //  functional //

	INX6_func INX6_behav_inst(.OUT(OUT),.IN(IN));
   `else

	INX6_func INX6_inst(.OUT(OUT),.IN(IN));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc IN --> OUT
	 (IN => OUT) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module INX8( OUT, IN );
input IN;
output OUT;

   `ifdef FUNCTIONAL  //  functional //

	INX8_func INX8_behav_inst(.OUT(OUT),.IN(IN));
   `else

	INX8_func INX8_inst(.OUT(OUT),.IN(IN));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc IN --> OUT
	 (IN => OUT) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module LGCPX1( GCLK, E, CLK );
input CLK, E;
output GCLK;

   `ifdef FUNCTIONAL  //  functional //

	LGCPX1_func LGCPX1_behav_inst(.GCLK(GCLK),.E(E),.CLK(CLK));
   `else

	LGCPX1_func LGCPX1_inst(.GCLK(GCLK),.E(E),.CLK(CLK));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc CLK --> GCLK
	 (CLK => GCLK) = (1.0,1.0);

	// hold E-HL CLK-LH
	$hold(posedge CLK,negedge E,1.0);

	// hold E-LH CLK-LH
	$hold(posedge CLK,posedge E,1.0);

	// setup E-HL CLK-LH
	$setup(negedge E,posedge CLK,1.0);

	// setup E-LH CLK-LH
	$setup(posedge E,posedge CLK,1.0);

	// mpw CLK_hl 
	$width(negedge CLK,1.0,0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module LGCPX2( GCLK, E, CLK );
input CLK, E;
output GCLK;

   `ifdef FUNCTIONAL  //  functional //

	LGCPX2_func LGCPX2_behav_inst(.GCLK(GCLK),.E(E),.CLK(CLK));
   `else

	LGCPX2_func LGCPX2_inst(.GCLK(GCLK),.E(E),.CLK(CLK));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc CLK --> GCLK
	 (CLK => GCLK) = (1.0,1.0);

	// hold E-HL CLK-LH
	$hold(posedge CLK,negedge E,1.0);

	// hold E-LH CLK-LH
	$hold(posedge CLK,posedge E,1.0);

	// setup E-HL CLK-LH
	$setup(negedge E,posedge CLK,1.0);

	// setup E-LH CLK-LH
	$setup(posedge E,posedge CLK,1.0);

	// mpw CLK_hl 
	$width(negedge CLK,1.0,0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module LGCPX3( GCLK, CLK, E );
input CLK, E;
output GCLK;

   `ifdef FUNCTIONAL  //  functional //

	LGCPX3_func LGCPX3_behav_inst(.GCLK(GCLK),.CLK(CLK),.E(E));
   `else

	LGCPX3_func LGCPX3_inst(.GCLK(GCLK),.CLK(CLK),.E(E));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc CLK --> GCLK
	 (CLK => GCLK) = (1.0,1.0);

	// hold E-HL CLK-LH
	$hold(posedge CLK,negedge E,1.0);

	// hold E-LH CLK-LH
	$hold(posedge CLK,posedge E,1.0);

	// setup E-HL CLK-LH
	$setup(negedge E,posedge CLK,1.0);

	// setup E-LH CLK-LH
	$setup(posedge E,posedge CLK,1.0);

	// mpw CLK_hl 
	$width(negedge CLK,1.0,0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module LOGIC0( Q );
output Q;

   `ifdef FUNCTIONAL  //  functional //

	LOGIC0_func LOGIC0_behav_inst(.Q(Q));
   `else

	LOGIC0_func LOGIC0_inst(.Q(Q));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module LOGIC1( Q );
output Q;

   `ifdef FUNCTIONAL  //  functional //

	LOGIC1_func LOGIC1_behav_inst(.Q(Q));
   `else

	LOGIC1_func LOGIC1_inst(.Q(Q));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module LSGCPX1( GCLK, SE, E, CLK );
input CLK, E, SE;
output GCLK;

   `ifdef FUNCTIONAL  //  functional //

	LSGCPX1_func LSGCPX1_behav_inst(.GCLK(GCLK),.SE(SE),.E(E),.CLK(CLK));
   `else

	LSGCPX1_func LSGCPX1_inst(.GCLK(GCLK),.SE(SE),.E(E),.CLK(CLK));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc CLK --> GCLK
	 (CLK => GCLK) = (1.0,1.0);

	// hold E-HL CLK-LH
	$hold(posedge CLK,negedge E,1.0);

	// hold E-LH CLK-LH
	$hold(posedge CLK,posedge E,1.0);

	// setup E-HL CLK-LH
	$setup(negedge E,posedge CLK,1.0);

	// setup E-LH CLK-LH
	$setup(posedge E,posedge CLK,1.0);

	// hold SE-HL CLK-LH
	$hold(posedge CLK,negedge SE,1.0);

	// hold SE-LH CLK-LH
	$hold(posedge CLK,posedge SE,1.0);

	// setup SE-HL CLK-LH
	$setup(negedge SE,posedge CLK,1.0);

	// setup SE-LH CLK-LH
	$setup(posedge SE,posedge CLK,1.0);

	// mpw CLK_hl 
	$width(negedge CLK,1.0,0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module LSGCPX2( GCLK, SE, E, CLK );
input CLK, E, SE;
output GCLK;

   `ifdef FUNCTIONAL  //  functional //

	LSGCPX2_func LSGCPX2_behav_inst(.GCLK(GCLK),.SE(SE),.E(E),.CLK(CLK));
   `else

	LSGCPX2_func LSGCPX2_inst(.GCLK(GCLK),.SE(SE),.E(E),.CLK(CLK));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc CLK --> GCLK
	 (CLK => GCLK) = (1.0,1.0);

	// hold E-HL CLK-LH
	$hold(posedge CLK,negedge E,1.0);

	// hold E-LH CLK-LH
	$hold(posedge CLK,posedge E,1.0);

	// setup E-HL CLK-LH
	$setup(negedge E,posedge CLK,1.0);

	// setup E-LH CLK-LH
	$setup(posedge E,posedge CLK,1.0);

	// hold SE-HL CLK-LH
	$hold(posedge CLK,negedge SE,1.0);

	// hold SE-LH CLK-LH
	$hold(posedge CLK,posedge SE,1.0);

	// setup SE-HL CLK-LH
	$setup(negedge SE,posedge CLK,1.0);

	// setup SE-LH CLK-LH
	$setup(posedge SE,posedge CLK,1.0);

	// mpw CLK_hl 
	$width(negedge CLK,1.0,0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module LSGCPX3( GCLK, CLK, E, SE );
input CLK, E, SE;
output GCLK;

   `ifdef FUNCTIONAL  //  functional //

	LSGCPX3_func LSGCPX3_behav_inst(.GCLK(GCLK),.CLK(CLK),.E(E),.SE(SE));
   `else

	LSGCPX3_func LSGCPX3_inst(.GCLK(GCLK),.CLK(CLK),.E(E),.SE(SE));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc CLK --> GCLK
	 (CLK => GCLK) = (1.0,1.0);

	// hold E-HL CLK-LH
	$hold(posedge CLK,negedge E,1.0);

	// hold E-LH CLK-LH
	$hold(posedge CLK,posedge E,1.0);

	// setup E-HL CLK-LH
	$setup(negedge E,posedge CLK,1.0);

	// setup E-LH CLK-LH
	$setup(posedge E,posedge CLK,1.0);

	// hold SE-HL CLK-LH
	$hold(posedge CLK,negedge SE,1.0);

	// hold SE-LH CLK-LH
	$hold(posedge CLK,posedge SE,1.0);

	// setup SE-HL CLK-LH
	$setup(negedge SE,posedge CLK,1.0);

	// setup SE-LH CLK-LH
	$setup(posedge SE,posedge CLK,1.0);

	// mpw CLK_hl 
	$width(negedge CLK,1.0,0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module LSOGCPX1( CGOBS, GCLK, SE, E, CLK );
input CLK, E, SE;
output CGOBS, GCLK;

   `ifdef FUNCTIONAL  //  functional //

	LSOGCPX1_func LSOGCPX1_behav_inst(.CGOBS(CGOBS),.GCLK(GCLK),.SE(SE),.E(E),.CLK(CLK));
   `else

	LSOGCPX1_func LSOGCPX1_inst(.CGOBS(CGOBS),.GCLK(GCLK),.SE(SE),.E(E),.CLK(CLK));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CLK --> CGOBS
	(negedge CLK => (CGOBS : E))  = (1.0,1.0);

	// comb arc E --> CGOBS
	 (E => CGOBS) = (1.0,1.0);

	// comb arc CLK --> GCLK
	 (CLK => GCLK) = (1.0,1.0);

	// comb arc SE --> GCLK
	 (SE => GCLK) = (1.0,1.0);

	// hold E-HL CLK-LH
	$hold(posedge CLK,negedge E,1.0);

	// hold E-LH CLK-LH
	$hold(posedge CLK,posedge E,1.0);

	// setup E-HL CLK-LH
	$setup(negedge E,posedge CLK,1.0);

	// setup E-LH CLK-LH
	$setup(posedge E,posedge CLK,1.0);

	// mpw CLK_hl 
	$width(negedge CLK,1.0,0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module LSOGCPX2( CGOBS, GCLK, SE, E, CLK );
input CLK, E, SE;
output CGOBS, GCLK;

   `ifdef FUNCTIONAL  //  functional //

	LSOGCPX2_func LSOGCPX2_behav_inst(.CGOBS(CGOBS),.GCLK(GCLK),.SE(SE),.E(E),.CLK(CLK));
   `else

	LSOGCPX2_func LSOGCPX2_inst(.CGOBS(CGOBS),.GCLK(GCLK),.SE(SE),.E(E),.CLK(CLK));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CLK --> CGOBS
	(negedge CLK => (CGOBS : E))  = (1.0,1.0);

	// comb arc E --> CGOBS
	 (E => CGOBS) = (1.0,1.0);

	// comb arc CLK --> GCLK
	 (CLK => GCLK) = (1.0,1.0);

	// comb arc SE --> GCLK
	 (SE => GCLK) = (1.0,1.0);

	// hold E-HL CLK-LH
	$hold(posedge CLK,negedge E,1.0);

	// hold E-LH CLK-LH
	$hold(posedge CLK,posedge E,1.0);

	// setup E-HL CLK-LH
	$setup(negedge E,posedge CLK,1.0);

	// setup E-LH CLK-LH
	$setup(posedge E,posedge CLK,1.0);

	// mpw CLK_hl 
	$width(negedge CLK,1.0,0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module LSOGCPX3( CGOBS, GCLK, SE, E, CLK );
input CLK, E, SE;
output CGOBS, GCLK;

   `ifdef FUNCTIONAL  //  functional //

	LSOGCPX3_func LSOGCPX3_behav_inst(.CGOBS(CGOBS),.GCLK(GCLK),.SE(SE),.E(E),.CLK(CLK));
   `else

	LSOGCPX3_func LSOGCPX3_inst(.CGOBS(CGOBS),.GCLK(GCLK),.SE(SE),.E(E),.CLK(CLK));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CLK --> CGOBS
	(negedge CLK => (CGOBS : E))  = (1.0,1.0);

	// comb arc E --> CGOBS
	 (E => CGOBS) = (1.0,1.0);

	// comb arc CLK --> GCLK
	 (CLK => GCLK) = (1.0,1.0);

	// comb arc SE --> GCLK
	 (SE => GCLK) = (1.0,1.0);

	// hold E-HL CLK-LH
	$hold(posedge CLK,negedge E,1.0);

	// hold E-LH CLK-LH
	$hold(posedge CLK,posedge E,1.0);

	// setup E-HL CLK-LH
	$setup(negedge E,posedge CLK,1.0);

	// setup E-LH CLK-LH
	$setup(posedge E,posedge CLK,1.0);

	// mpw CLK_hl 
	$width(negedge CLK,1.0,0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module MU2IX1( QN, S, IN0, IN1 );
input IN0, IN1, S;
output QN;

   `ifdef FUNCTIONAL  //  functional //

	MU2IX1_func MU2IX1_behav_inst(.QN(QN),.S(S),.IN0(IN0),.IN1(IN1));
   `else

	MU2IX1_func MU2IX1_inst(.QN(QN),.S(S),.IN0(IN0),.IN1(IN1));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc IN0 --> QN
	 (IN0 => QN) = (1.0,1.0);

	// comb arc IN1 --> QN
	 (IN1 => QN) = (1.0,1.0);

	ifnone
	// comb arc posedge S --> (QN:S)
	 (posedge S => (QN:S)) = (1.0,1.0);

	ifnone
	// comb arc negedge S --> (QN:S)
	 (negedge S => (QN:S)) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module MU2X1( Q, IN0, IN1, S );
input IN0, IN1, S;
output Q;

   `ifdef FUNCTIONAL  //  functional //

	MU2X1_func MU2X1_behav_inst(.Q(Q),.IN0(IN0),.IN1(IN1),.S(S));
   `else

	MU2X1_func MU2X1_inst(.Q(Q),.IN0(IN0),.IN1(IN1),.S(S));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc IN0 --> Q
	 (IN0 => Q) = (1.0,1.0);

	// comb arc IN1 --> Q
	 (IN1 => Q) = (1.0,1.0);

	ifnone
	// comb arc posedge S --> (Q:S)
	 (posedge S => (Q:S)) = (1.0,1.0);

	ifnone
	// comb arc negedge S --> (Q:S)
	 (negedge S => (Q:S)) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module MU4IX1( NQ, IN1, IN0, S0, IN3, IN2, S1 );
input IN0, IN1, IN2, IN3, S0, S1;
output NQ;

   `ifdef FUNCTIONAL  //  functional //

	MU4IX1_func MU4IX1_behav_inst(.NQ(NQ),.IN1(IN1),.IN0(IN0),.S0(S0),.IN3(IN3),.IN2(IN2),.S1(S1));
   `else

	MU4IX1_func MU4IX1_inst(.NQ(NQ),.IN1(IN1),.IN0(IN0),.S0(S0),.IN3(IN3),.IN2(IN2),.S1(S1));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc IN0 --> NQ
	 (IN0 => NQ) = (1.0,1.0);

	// comb arc IN1 --> NQ
	 (IN1 => NQ) = (1.0,1.0);

	// comb arc IN2 --> NQ
	 (IN2 => NQ) = (1.0,1.0);

	// comb arc IN3 --> NQ
	 (IN3 => NQ) = (1.0,1.0);

	ifnone
	// comb arc posedge S0 --> (NQ:S0)
	 (posedge S0 => (NQ:S0)) = (1.0,1.0);

	ifnone
	// comb arc negedge S0 --> (NQ:S0)
	 (negedge S0 => (NQ:S0)) = (1.0,1.0);

	ifnone
	// comb arc posedge S1 --> (NQ:S1)
	 (posedge S1 => (NQ:S1)) = (1.0,1.0);

	ifnone
	// comb arc negedge S1 --> (NQ:S1)
	 (negedge S1 => (NQ:S1)) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module MU4X1( Q, IN1, IN0, S0, IN3, IN2, S1 );
input IN0, IN1, IN2, IN3, S0, S1;
output Q;

   `ifdef FUNCTIONAL  //  functional //

	MU4X1_func MU4X1_behav_inst(.Q(Q),.IN1(IN1),.IN0(IN0),.S0(S0),.IN3(IN3),.IN2(IN2),.S1(S1));
   `else

	MU4X1_func MU4X1_inst(.Q(Q),.IN1(IN1),.IN0(IN0),.S0(S0),.IN3(IN3),.IN2(IN2),.S1(S1));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc IN0 --> Q
	 (IN0 => Q) = (1.0,1.0);

	// comb arc IN1 --> Q
	 (IN1 => Q) = (1.0,1.0);

	// comb arc IN2 --> Q
	 (IN2 => Q) = (1.0,1.0);

	// comb arc IN3 --> Q
	 (IN3 => Q) = (1.0,1.0);

	ifnone
	// comb arc posedge S0 --> (Q:S0)
	 (posedge S0 => (Q:S0)) = (1.0,1.0);

	ifnone
	// comb arc negedge S0 --> (Q:S0)
	 (negedge S0 => (Q:S0)) = (1.0,1.0);

	ifnone
	// comb arc posedge S1 --> (Q:S1)
	 (posedge S1 => (Q:S1)) = (1.0,1.0);

	ifnone
	// comb arc negedge S1 --> (Q:S1)
	 (negedge S1 => (Q:S1)) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module NA2I1X1( OUT, B, A );
input A, B;
output OUT;

   `ifdef FUNCTIONAL  //  functional //

	NA2I1X1_func NA2I1X1_behav_inst(.OUT(OUT),.B(B),.A(A));
   `else

	NA2I1X1_func NA2I1X1_inst(.OUT(OUT),.B(B),.A(A));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> OUT
	 (A => OUT) = (1.0,1.0);

	// comb arc B --> OUT
	 (B => OUT) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module NA2X1( OUT, A, B );
input A, B;
output OUT;

   `ifdef FUNCTIONAL  //  functional //

	NA2X1_func NA2X1_behav_inst(.OUT(OUT),.A(A),.B(B));
   `else

	NA2X1_func NA2X1_inst(.OUT(OUT),.A(A),.B(B));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> OUT
	 (A => OUT) = (1.0,1.0);

	// comb arc B --> OUT
	 (B => OUT) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module NA3I1X1( OUT, NA, C, B );
input B, C, NA;
output OUT;

   `ifdef FUNCTIONAL  //  functional //

	NA3I1X1_func NA3I1X1_behav_inst(.OUT(OUT),.NA(NA),.C(C),.B(B));
   `else

	NA3I1X1_func NA3I1X1_inst(.OUT(OUT),.NA(NA),.C(C),.B(B));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc B --> OUT
	 (B => OUT) = (1.0,1.0);

	// comb arc C --> OUT
	 (C => OUT) = (1.0,1.0);

	// comb arc NA --> OUT
	 (NA => OUT) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module NA3I2X1( OUT, A, C, B );
input A, B, C;
output OUT;

   `ifdef FUNCTIONAL  //  functional //

	NA3I2X1_func NA3I2X1_behav_inst(.OUT(OUT),.A(A),.C(C),.B(B));
   `else

	NA3I2X1_func NA3I2X1_inst(.OUT(OUT),.A(A),.C(C),.B(B));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> OUT
	 (A => OUT) = (1.0,1.0);

	// comb arc B --> OUT
	 (B => OUT) = (1.0,1.0);

	// comb arc C --> OUT
	 (C => OUT) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module NA3X1( OUT, A, B, C );
input A, B, C;
output OUT;

   `ifdef FUNCTIONAL  //  functional //

	NA3X1_func NA3X1_behav_inst(.OUT(OUT),.A(A),.B(B),.C(C));
   `else

	NA3X1_func NA3X1_inst(.OUT(OUT),.A(A),.B(B),.C(C));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> OUT
	 (A => OUT) = (1.0,1.0);

	// comb arc B --> OUT
	 (B => OUT) = (1.0,1.0);

	// comb arc C --> OUT
	 (C => OUT) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module NA4I1X1( OUT, A, B, C, D );
input A, B, C, D;
output OUT;

   `ifdef FUNCTIONAL  //  functional //

	NA4I1X1_func NA4I1X1_behav_inst(.OUT(OUT),.A(A),.B(B),.C(C),.D(D));
   `else

	NA4I1X1_func NA4I1X1_inst(.OUT(OUT),.A(A),.B(B),.C(C),.D(D));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> OUT
	 (A => OUT) = (1.0,1.0);

	// comb arc B --> OUT
	 (B => OUT) = (1.0,1.0);

	// comb arc C --> OUT
	 (C => OUT) = (1.0,1.0);

	// comb arc D --> OUT
	 (D => OUT) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module NA4I2X1( OUT, A, B, C, D );
input A, B, C, D;
output OUT;

   `ifdef FUNCTIONAL  //  functional //

	NA4I2X1_func NA4I2X1_behav_inst(.OUT(OUT),.A(A),.B(B),.C(C),.D(D));
   `else

	NA4I2X1_func NA4I2X1_inst(.OUT(OUT),.A(A),.B(B),.C(C),.D(D));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> OUT
	 (A => OUT) = (1.0,1.0);

	// comb arc B --> OUT
	 (B => OUT) = (1.0,1.0);

	// comb arc C --> OUT
	 (C => OUT) = (1.0,1.0);

	// comb arc D --> OUT
	 (D => OUT) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module NA4I3X1( OUT, A, B, D, C );
input A, B, C, D;
output OUT;

   `ifdef FUNCTIONAL  //  functional //

	NA4I3X1_func NA4I3X1_behav_inst(.OUT(OUT),.A(A),.B(B),.D(D),.C(C));
   `else

	NA4I3X1_func NA4I3X1_inst(.OUT(OUT),.A(A),.B(B),.D(D),.C(C));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> OUT
	 (A => OUT) = (1.0,1.0);

	// comb arc B --> OUT
	 (B => OUT) = (1.0,1.0);

	// comb arc C --> OUT
	 (C => OUT) = (1.0,1.0);

	// comb arc D --> OUT
	 (D => OUT) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module NA4X1( OUT, B, A, C, D );
input A, B, C, D;
output OUT;

   `ifdef FUNCTIONAL  //  functional //

	NA4X1_func NA4X1_behav_inst(.OUT(OUT),.B(B),.A(A),.C(C),.D(D));
   `else

	NA4X1_func NA4X1_inst(.OUT(OUT),.B(B),.A(A),.C(C),.D(D));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> OUT
	 (A => OUT) = (1.0,1.0);

	// comb arc B --> OUT
	 (B => OUT) = (1.0,1.0);

	// comb arc C --> OUT
	 (C => OUT) = (1.0,1.0);

	// comb arc D --> OUT
	 (D => OUT) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module NA5I1X1( OUT, A, B, E, C, D );
input A, B, C, D, E;
output OUT;

   `ifdef FUNCTIONAL  //  functional //

	NA5I1X1_func NA5I1X1_behav_inst(.OUT(OUT),.A(A),.B(B),.E(E),.C(C),.D(D));
   `else

	NA5I1X1_func NA5I1X1_inst(.OUT(OUT),.A(A),.B(B),.E(E),.C(C),.D(D));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> OUT
	 (A => OUT) = (1.0,1.0);

	// comb arc B --> OUT
	 (B => OUT) = (1.0,1.0);

	// comb arc C --> OUT
	 (C => OUT) = (1.0,1.0);

	// comb arc D --> OUT
	 (D => OUT) = (1.0,1.0);

	// comb arc E --> OUT
	 (E => OUT) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module NA5X1( OUT, A, B, E, C, D );
input A, B, C, D, E;
output OUT;

   `ifdef FUNCTIONAL  //  functional //

	NA5X1_func NA5X1_behav_inst(.OUT(OUT),.A(A),.B(B),.E(E),.C(C),.D(D));
   `else

	NA5X1_func NA5X1_inst(.OUT(OUT),.A(A),.B(B),.E(E),.C(C),.D(D));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> OUT
	 (A => OUT) = (1.0,1.0);

	// comb arc B --> OUT
	 (B => OUT) = (1.0,1.0);

	// comb arc C --> OUT
	 (C => OUT) = (1.0,1.0);

	// comb arc D --> OUT
	 (D => OUT) = (1.0,1.0);

	// comb arc E --> OUT
	 (E => OUT) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module NA6X1( OUT, B, A, E, D, F, C );
input A, B, C, D, E, F;
output OUT;

   `ifdef FUNCTIONAL  //  functional //

	NA6X1_func NA6X1_behav_inst(.OUT(OUT),.B(B),.A(A),.E(E),.D(D),.F(F),.C(C));
   `else

	NA6X1_func NA6X1_inst(.OUT(OUT),.B(B),.A(A),.E(E),.D(D),.F(F),.C(C));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> OUT
	 (A => OUT) = (1.0,1.0);

	// comb arc B --> OUT
	 (B => OUT) = (1.0,1.0);

	// comb arc C --> OUT
	 (C => OUT) = (1.0,1.0);

	// comb arc D --> OUT
	 (D => OUT) = (1.0,1.0);

	// comb arc E --> OUT
	 (E => OUT) = (1.0,1.0);

	// comb arc F --> OUT
	 (F => OUT) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module NO2X1( OUT, A, B );
input A, B;
output OUT;

   `ifdef FUNCTIONAL  //  functional //

	NO2X1_func NO2X1_behav_inst(.OUT(OUT),.A(A),.B(B));
   `else

	NO2X1_func NO2X1_inst(.OUT(OUT),.A(A),.B(B));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> OUT
	 (A => OUT) = (1.0,1.0);

	// comb arc B --> OUT
	 (B => OUT) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module NO3X1( OUT, A, B, C );
input A, B, C;
output OUT;

   `ifdef FUNCTIONAL  //  functional //

	NO3X1_func NO3X1_behav_inst(.OUT(OUT),.A(A),.B(B),.C(C));
   `else

	NO3X1_func NO3X1_inst(.OUT(OUT),.A(A),.B(B),.C(C));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> OUT
	 (A => OUT) = (1.0,1.0);

	// comb arc B --> OUT
	 (B => OUT) = (1.0,1.0);

	// comb arc C --> OUT
	 (C => OUT) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module NO4X1( OUT, B, A, C, D );
input A, B, C, D;
output OUT;

   `ifdef FUNCTIONAL  //  functional //

	NO4X1_func NO4X1_behav_inst(.OUT(OUT),.B(B),.A(A),.C(C),.D(D));
   `else

	NO4X1_func NO4X1_inst(.OUT(OUT),.B(B),.A(A),.C(C),.D(D));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> OUT
	 (A => OUT) = (1.0,1.0);

	// comb arc B --> OUT
	 (B => OUT) = (1.0,1.0);

	// comb arc C --> OUT
	 (C => OUT) = (1.0,1.0);

	// comb arc D --> OUT
	 (D => OUT) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module NO5X1( OUT, E, B, A, C, D );
input A, B, C, D, E;
output OUT;

   `ifdef FUNCTIONAL  //  functional //

	NO5X1_func NO5X1_behav_inst(.OUT(OUT),.E(E),.B(B),.A(A),.C(C),.D(D));
   `else

	NO5X1_func NO5X1_inst(.OUT(OUT),.E(E),.B(B),.A(A),.C(C),.D(D));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> OUT
	 (A => OUT) = (1.0,1.0);

	// comb arc B --> OUT
	 (B => OUT) = (1.0,1.0);

	// comb arc C --> OUT
	 (C => OUT) = (1.0,1.0);

	// comb arc D --> OUT
	 (D => OUT) = (1.0,1.0);

	// comb arc E --> OUT
	 (E => OUT) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module NO6X1( OUT, F, D, C, A, E, B );
input A, B, C, D, E, F;
output OUT;

   `ifdef FUNCTIONAL  //  functional //

	NO6X1_func NO6X1_behav_inst(.OUT(OUT),.F(F),.D(D),.C(C),.A(A),.E(E),.B(B));
   `else

	NO6X1_func NO6X1_inst(.OUT(OUT),.F(F),.D(D),.C(C),.A(A),.E(E),.B(B));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> OUT
	 (A => OUT) = (1.0,1.0);

	// comb arc B --> OUT
	 (B => OUT) = (1.0,1.0);

	// comb arc C --> OUT
	 (C => OUT) = (1.0,1.0);

	// comb arc D --> OUT
	 (D => OUT) = (1.0,1.0);

	// comb arc E --> OUT
	 (E => OUT) = (1.0,1.0);

	// comb arc F --> OUT
	 (F => OUT) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module OA211X1( OUT, B, A, D, C );
input A, B, C, D;
output OUT;

   `ifdef FUNCTIONAL  //  functional //

	OA211X1_func OA211X1_behav_inst(.OUT(OUT),.B(B),.A(A),.D(D),.C(C));
   `else

	OA211X1_func OA211X1_inst(.OUT(OUT),.B(B),.A(A),.D(D),.C(C));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> OUT
	 (A => OUT) = (1.0,1.0);

	// comb arc B --> OUT
	 (B => OUT) = (1.0,1.0);

	// comb arc C --> OUT
	 (C => OUT) = (1.0,1.0);

	// comb arc D --> OUT
	 (D => OUT) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module ON32X1( OUT, A, B, C, D, E );
input A, B, C, D, E;
output OUT;

   `ifdef FUNCTIONAL  //  functional //

	ON32X1_func ON32X1_behav_inst(.OUT(OUT),.A(A),.B(B),.C(C),.D(D),.E(E));
   `else

	ON32X1_func ON32X1_inst(.OUT(OUT),.A(A),.B(B),.C(C),.D(D),.E(E));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> OUT
	 (A => OUT) = (1.0,1.0);

	// comb arc B --> OUT
	 (B => OUT) = (1.0,1.0);

	// comb arc C --> OUT
	 (C => OUT) = (1.0,1.0);

	// comb arc D --> OUT
	 (D => OUT) = (1.0,1.0);

	// comb arc E --> OUT
	 (E => OUT) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module OR2X1( OUT, A, B );
input A, B;
output OUT;

   `ifdef FUNCTIONAL  //  functional //

	OR2X1_func OR2X1_behav_inst(.OUT(OUT),.A(A),.B(B));
   `else

	OR2X1_func OR2X1_inst(.OUT(OUT),.A(A),.B(B));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> OUT
	 (A => OUT) = (1.0,1.0);

	// comb arc B --> OUT
	 (B => OUT) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module OR3X1( OUT, A, B, C );
input A, B, C;
output OUT;

   `ifdef FUNCTIONAL  //  functional //

	OR3X1_func OR3X1_behav_inst(.OUT(OUT),.A(A),.B(B),.C(C));
   `else

	OR3X1_func OR3X1_inst(.OUT(OUT),.A(A),.B(B),.C(C));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> OUT
	 (A => OUT) = (1.0,1.0);

	// comb arc B --> OUT
	 (B => OUT) = (1.0,1.0);

	// comb arc C --> OUT
	 (C => OUT) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module SDFRX1( Q, QN, ICLK, SD, SE, D );
input D, ICLK, SD, SE;
output Q, QN;

   `ifdef FUNCTIONAL  //  functional //

	SDFRX1_func SDFRX1_behav_inst(.Q(Q),.QN(QN),.ICLK(ICLK),.SD(SD),.SE(SE),.D(D));
   `else

	SDFRX1_func SDFRX1_inst(.Q(Q),.QN(QN),.ICLK(ICLK),.SD(SD),.SE(SE),.D(D));

	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc ICLK --> Q
	(posedge ICLK => (Q : D))  = (1.0,1.0);

	// seq arc ICLK --> QN
	(posedge ICLK => (QN : D))  = (1.0,1.0);

	// hold D-HL ICLK-LH
	$hold(posedge ICLK,negedge D,1.0);

	// hold D-LH ICLK-LH
	$hold(posedge ICLK,posedge D,1.0);

	// setup D-HL ICLK-LH
	$setup(negedge D,posedge ICLK,1.0);

	// setup D-LH ICLK-LH
	$setup(posedge D,posedge ICLK,1.0);

	// hold SD-HL ICLK-LH
	$hold(posedge ICLK,negedge SD,1.0);

	// hold SD-LH ICLK-LH
	$hold(posedge ICLK,posedge SD,1.0);

	// setup SD-HL ICLK-LH
	$setup(negedge SD,posedge ICLK,1.0);

	// setup SD-LH ICLK-LH
	$setup(posedge SD,posedge ICLK,1.0);

	// hold SE-HL ICLK-LH
	$hold(posedge ICLK,negedge SE,1.0);

	// hold SE-LH ICLK-LH
	$hold(posedge ICLK,posedge SE,1.0);

	// setup SE-HL ICLK-LH
	$setup(negedge SE,posedge ICLK,1.0);

	// setup SE-LH ICLK-LH
	$setup(posedge SE,posedge ICLK,1.0);

	// mpw ICLK_lh 
	$width(posedge ICLK,1.0,0);

	// mpw ICLK_hl 
	$width(negedge ICLK,1.0,0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine
